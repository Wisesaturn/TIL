[{"title":"로또의 최고 순위와 최저 순위","type":0,"sectionRef":"#","url":"docs/CodingTest/프로그래머스/Level 1/로또의 최고 순위와 최저 순위","content":"","keywords":""},{"title":"📒 문제 설명​","type":1,"pageTitle":"로또의 최고 순위와 최저 순위","url":"docs/CodingTest/프로그래머스/Level 1/로또의 최고 순위와 최저 순위#-문제-설명","content":"https://programmers.co.kr/learn/courses/30/lessons/77484 "},{"title":"💻 언어​","type":1,"pageTitle":"로또의 최고 순위와 최저 순위","url":"docs/CodingTest/프로그래머스/Level 1/로또의 최고 순위와 최저 순위#-언어","content":"C++  "},{"title":"풀이​","type":1,"pageTitle":"로또의 최고 순위와 최저 순위","url":"docs/CodingTest/프로그래머스/Level 1/로또의 최고 순위와 최저 순위#풀이","content":"입력 배열과 당첨 배열을 parameter로 받는다.크기 2의 최저 순위와 최고 순위값을 넣을 result vector를 선언한다. 굳이 vector가 아니어도 일반 변수를 선언해도 상관 없다. for 중첩문을 활용한다. "},{"title":"관련 알고리즘​","type":1,"pageTitle":"로또의 최고 순위와 최저 순위","url":"docs/CodingTest/프로그래머스/Level 1/로또의 최고 순위와 최저 순위#관련-알고리즘","content":"-  "},{"title":"사고 과정​","type":1,"pageTitle":"로또의 최고 순위와 최저 순위","url":"docs/CodingTest/프로그래머스/Level 1/로또의 최고 순위와 최저 순위#사고-과정","content":""},{"title":"📌 최고 순위 파악​","type":1,"pageTitle":"로또의 최고 순위와 최저 순위","url":"docs/CodingTest/프로그래머스/Level 1/로또의 최고 순위와 최저 순위#-최고-순위-파악","content":"첫 번째 for문에서는 최고 순위일 때를 Count한다.(it != win_nums.end() || lottos[j] == 0의 조건은 다음과 같다. 알아볼 수 없는 숫자가 나올 때 (0의 입력값일 때)iterator를 통해 값을 찾을 수 없지 않을 때 (== 값이 있을 때) 만약, 값이 없다면 당첨된 번호가 아닌 것이다. 이 과정을 통해 최고 순위를 Count한다. "},{"title":"📌 최저 순위 파악​","type":1,"pageTitle":"로또의 최고 순위와 최저 순위","url":"docs/CodingTest/프로그래머스/Level 1/로또의 최고 순위와 최저 순위#-최저-순위-파악","content":"두 번째 for문에서는 최저 순위일 때를 Count한다.it != win_nums.end()의 조건은 다음과 같다. iterator를 통해 값을 찾을 수 없지 않을 때 (== 값이 있을 때) 만약, 값이 없다면 당첨된 번호가 아닌 것이다. 이 과정을 통해 최저 순위를 Count한다. "},{"title":"📌 Count한 숫자로 순위 매기기​","type":1,"pageTitle":"로또의 최고 순위와 최저 순위","url":"docs/CodingTest/프로그래머스/Level 1/로또의 최고 순위와 최저 순위#-count한-숫자로-순위-매기기","content":"각각 순위 파악이 끝나면 Count한 값을 통해 순위를 매긴다.result[i] = (result[i] - 7) * -1;의 조건은 다음과 같다. Count한 값이 많을수록 순위는 높아진다. 다르게 말하면, 순위값은 낮아진다. (1등 = 1의 값)Count한 값을 역순으로 돌리면 쉽게 순위값을 얻을 수 있다.Count한 값을 역순으로 만들되 1 ~ 6의 범위가 나올 수 있도록 한다.Count한 값 -7 (0 ~ 6 범위에서 -7 ~ -1로 변경)해당 값에 -1을 곱한다 (1 ~ 7의 범위로 변경)이 때 -7은 순위에 포함되지 않으므로 Count 값이 0일 때를 따로 부여한다. (Count 값이 0일 경우 순위는 6위) "},{"title":"결과​","type":1,"pageTitle":"로또의 최고 순위와 최저 순위","url":"docs/CodingTest/프로그래머스/Level 1/로또의 최고 순위와 최저 순위#결과","content":"#include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; vector&lt;int&gt; solution(vector&lt;int&gt; lottos, vector&lt;int&gt; win_nums) { vector&lt;int&gt; result(2); vector&lt;int&gt;::iterator it; for (size_t i = 0; i &lt; 2; i++) { for (size_t j = 0; j &lt; 6; j++) { it = find(win_nums.begin(), win_nums.end(), lottos[j]); if (i == 0) { // 최고일 때 if (it != win_nums.end() || lottos[j] == 0) result[i]++; } else { // 최저일 때 if (it != win_nums.end()) result[i]++; } } if (result[i] != 0) result[i] = (result[i] - 7) * -1; else result[i] = 6; } return result; }  "},{"title":"다음 큰 숫자","type":0,"sectionRef":"#","url":"docs/CodingTest/프로그래머스/Level 2/다음 큰 숫자","content":"","keywords":""},{"title":"📒 문제 설명​","type":1,"pageTitle":"다음 큰 숫자","url":"docs/CodingTest/프로그래머스/Level 2/다음 큰 숫자#-문제-설명","content":"https://school.programmers.co.kr/learn/courses/30/lessons/12911 "},{"title":"💻 언어​","type":1,"pageTitle":"다음 큰 숫자","url":"docs/CodingTest/프로그래머스/Level 2/다음 큰 숫자#-언어","content":"C++  "},{"title":"풀이​","type":1,"pageTitle":"다음 큰 숫자","url":"docs/CodingTest/프로그래머스/Level 2/다음 큰 숫자#풀이","content":"처음에 n을 2진수로 변환하여 1의 갯수를 파악한다 (함수 선언)n+1부터 시작하여 수를 늘려간다. 이 때, n을 함수에 대입한 값과 같아질 때까지 늘려간다. 구한 값을 return한다. "},{"title":"관련 알고리즘​","type":1,"pageTitle":"다음 큰 숫자","url":"docs/CodingTest/프로그래머스/Level 2/다음 큰 숫자#관련-알고리즘","content":"-  "},{"title":"사고 과정​","type":1,"pageTitle":"다음 큰 숫자","url":"docs/CodingTest/프로그래머스/Level 2/다음 큰 숫자#사고-과정","content":""},{"title":"📌 특정 숫자를 2진수로 변환​","type":1,"pageTitle":"다음 큰 숫자","url":"docs/CodingTest/프로그래머스/Level 2/다음 큰 숫자#-특정-숫자를-2진수로-변환","content":"특정 입력값을 2진수로 변환한다.이 때, 나누기와 나머지 연산을 활용한다. 나머지가 1일 때, 1의 갯수를 카운팅한다. 1이 남을 때까지 연산은 지속되며, 연산 종료 후 카운팅한 값을 return한다. "},{"title":"📌 n+1부터 1의 갯수 파악​","type":1,"pageTitle":"다음 큰 숫자","url":"docs/CodingTest/프로그래머스/Level 2/다음 큰 숫자#-n1부터-1의-갯수-파악","content":"n+1부터 1의 갯수를 파악한다. 함수로 만들어놓았으므로 if 조건문내에서 ++연산을 활용해 효율적으로 작성한다. 1의 갯수가 같다면 그 값을 return한다. "},{"title":"결과​","type":1,"pageTitle":"다음 큰 숫자","url":"docs/CodingTest/프로그래머스/Level 2/다음 큰 숫자#결과","content":"#include &lt;string&gt; #include &lt;vector&gt; using namespace std; // 0. 2진수로 변환하여 1의 갯수를 파악하는 함수를 만든다. int func(int n) { int count = 0; do { if (n % 2 != 0) count++; n /= 2; } while(n &gt;= 1); return count; } int solution(int n) { // 1. n의 1의 갯수를 파악한다. int correct = func(n); // 2. n+1부터 시작하여 수를 늘려간다. // 이 때, 1번에서 계산했던 갯수가 같아질 때까지 늘려간다. while(true) { if (correct == func(++n)) { // 3. 2번 과정에서 구한 값을 return return n; } } }  "},{"title":"Cookie & Session","type":0,"sectionRef":"#","url":"docs/CS/Network/Cookie & Session","content":"","keywords":""},{"title":"📌 쿠키와 세션을 사용하는 이유​","type":1,"pageTitle":"Cookie & Session","url":"docs/CS/Network/Cookie & Session#-쿠키와-세션을-사용하는-이유","content":"HTTP 프로토콜은 일반적으로 Connectionless, Stateless한 환경입니다. 이로써 server는 User가 누구인지 매번 확인해야 하는 상황이 생깁니다. 이를 보완하기 위해 Session과 Cookie를 이용합니다.  "},{"title":"Connectionless (비연결성)​","type":1,"pageTitle":"Cookie & Session","url":"docs/CS/Network/Cookie & Session#connectionless-비연결성","content":"User와 Server간 통신을 할 때 request와 response를 주고받은 후 바로 연결이 끊기는 특징​ 연결을 유지하기 위해 resource를 줄여 더 많이 연결할 수 있으나 매번 연결 과정을 반복해야하므로 Overheading이 발생할 수 있습니다.이에 대한 해결책으로 KeepAlive 속성을 HTTP1.1부터 Default로 가지고 있습니다. 이는 지정된 시간동안 Packet 교환이 없을 경우, 접속을 끊기 전 어느 정도 Packet을 주기적으로 보내는 것을 의미합니다. 이를 통해 Client 상태 체크를 하나 서버에 과부하가 걸릴 경우 역시 한계가 존재합니다.  "},{"title":"Stateless (무상태)​","type":1,"pageTitle":"Cookie & Session","url":"docs/CS/Network/Cookie & Session#stateless-무상태","content":"Server는 User를 식별할 수 없습니다. 즉, Client가 누군지 모릅니다.​  "},{"title":"🍪 Cookie​","type":1,"pageTitle":"Cookie & Session","url":"docs/CS/Network/Cookie & Session#-cookie","content":"Client Browser 내에 저장되는 데이터 파일​ key, value, expired, ,domain, path로 정보가 이루어져 있다.브라우저가 종료되어도 데이터를 갖고 있어 인증이 유지된다.하나의 Cookie는 4KB까지 저장이 가능하다.Client에 300개까지 저장할 수 있으며, 하나의 Domain당 20개의 값만 가질 수 있다.쿠키는 사용자가 따로 요청하지 않아도 Browser가 Request시 Request Header에 넣어서 자동으로 서버에 전송한다. "},{"title":"구성요소​","type":1,"pageTitle":"Cookie & Session","url":"docs/CS/Network/Cookie & Session#구성요소","content":"key(name) : Cookie의 고유한 이름value : 쿠키와 관련된 값expired : 쿠키의 유지 시간domain : 쿠키를 전송할 도메인path : 쿠키를 전송할 요청 경로 "},{"title":"동작 방식​","type":1,"pageTitle":"Cookie & Session","url":"docs/CS/Network/Cookie & Session#동작-방식","content":"Client가 Server에 Page를 요청Server에서 Cookie를 생성 Frontend Server/Backend Server 상관없이 Cookie 생성이 모두 가능하다. HTTP Header에 Cookie를 포함하여 ResponseCookie 만료 기간이 지날 때까지 Client의 Browser에 보관Client가 같은 Request를 할 경우 HTTP Header에 자동으로 Cookie를 함께 보냄 "},{"title":"🔩 Session​","type":1,"pageTitle":"Cookie & Session","url":"docs/CS/Network/Cookie & Session#-session","content":"Cookie 기반 Server 측에서 관리하는 데이터 파일​ Server 측에서는 Client를 구분하기 위해 각각 고유의 Session ID를 부여한다. Client가 Request를 보내면, Server에서 Session ID를 부여 Browser가 종료되거나 Server에서 Session을 삭제하면 인증이 만료된다.Server에서 관리하므로 쿠키보다 보안이 좋으나, 사용자가 많아질수록 Server Memory에 부하가 걸린다. "},{"title":"동작 방식​","type":1,"pageTitle":"Cookie & Session","url":"docs/CS/Network/Cookie & Session#동작-방식-1","content":"Client가 Server에 접속 시 Session ID 발급Client는 Session ID를 Cookie를 이용해 가지고 있음Server에 요청할 때 Session ID를 같이 서버에 HTTP Header에 equestServer는 Session ID를 전달받아 Session에 있는 Client 정보를 사용Server 요청을 처리 후 Client에 응답 "}]